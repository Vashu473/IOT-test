<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ESP32 Audio Receiver</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f5f5f5;
        color: #333;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
      }
      .container {
        max-width: 600px;
        width: 100%;
        background-color: #fff;
        padding: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        border-radius: 8px;
      }
      h1 {
        color: #2c3e50;
        margin-top: 0;
        text-align: center;
      }
      .status {
        margin: 20px 0;
        padding: 10px;
        background-color: #e9f7fe;
        border-left: 4px solid #3498db;
        border-radius: 4px;
        text-align: center;
      }
      .status.error {
        background-color: #ffeaea;
        border-left-color: #e74c3c;
      }
      .status.success {
        background-color: #eafff2;
        border-left-color: #2ecc71;
      }
      canvas {
        display: block;
        width: 100%;
        height: 150px;
        background-color: #2c3e50;
        margin: 20px 0;
        border-radius: 4px;
      }
      footer {
        margin-top: 20px;
        text-align: center;
        color: #7f8c8d;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ESP32 Audio Stream</h1>

      <div id="connectionStatus" class="status">Connecting to server...</div>

      <canvas id="visualizer"></canvas>

      <footer>ESP32-S3-DevKitc-1 Audio Stream Receiver</footer>
    </div>

    <script>
      // Audio context for playback
      let audioContext = null;
      let socket = null;
      let isConnected = false;

      // DOM elements
      const connectionStatus = document.getElementById("connectionStatus");
      const canvas = document.getElementById("visualizer");
      const canvasCtx = canvas.getContext("2d");

      // Set actual canvas dimensions
      function resizeCanvas() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // Initialize audio context
      function initAudio() {
        try {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          return true;
        } catch (e) {
          console.error("Error initializing audio context:", e);
          connectionStatus.textContent =
            "Error: Web Audio API not supported in this browser.";
          connectionStatus.classList.add("error");
          return false;
        }
      }

      // Start WebSocket connection
      function connectWebSocket() {
        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${protocol}//${window.location.host}`;

        socket = new WebSocket(wsUrl);

        socket.onopen = (event) => {
          isConnected = true;
          connectionStatus.textContent =
            "Connected to server - Audio streaming active";
          connectionStatus.classList.add("success");
          connectionStatus.classList.remove("error");

          console.log(
            "[WebSocket] Connected successfully - ready to receive audio"
          );

          // Resume audio context (required by some browsers)
          if (audioContext && audioContext.state === "suspended") {
            audioContext.resume();
          }
        };

        socket.onclose = (event) => {
          isConnected = false;
          connectionStatus.textContent =
            "Disconnected from server. Reconnecting...";
          connectionStatus.classList.add("error");
          connectionStatus.classList.remove("success");

          console.log(
            "[WebSocket] Connection closed. Attempting to reconnect in 5 seconds..."
          );

          // Try to reconnect after a delay
          setTimeout(connectWebSocket, 5000);
        };

        socket.onerror = (error) => {
          console.error("WebSocket error:", error);
          connectionStatus.textContent =
            "WebSocket error - check console for details";
          connectionStatus.classList.add("error");
        };

        socket.onmessage = (event) => {
          try {
            if (typeof event.data === "string") {
              try {
                // Parse JSON message
                const data = JSON.parse(event.data);

                console.log("Received message type:", data.type);

                if (data.type === "audio" && data.format === "pcm") {
                  // Handle PCM audio data
                  const pcmData = new Int16Array(data.data);

                  console.log(
                    `Received audio data: ${pcmData.length} samples, sample rate: ${data.sampleRate}`
                  );

                  // Only process if there's actual audio data
                  if (pcmData && pcmData.length > 0) {
                    try {
                      // Check for non-zero values
                      let nonZeroCount = 0;
                      let maxAmplitude = 0;

                      for (let i = 0; i < pcmData.length; i++) {
                        if (pcmData[i] !== 0) {
                          nonZeroCount++;
                          maxAmplitude = Math.max(
                            maxAmplitude,
                            Math.abs(pcmData[i])
                          );
                        }
                      }

                      console.log(
                        `Audio data quality: ${nonZeroCount}/${
                          pcmData.length
                        } non-zero samples (${(
                          (nonZeroCount / pcmData.length) *
                          100
                        ).toFixed(1)}%), max amplitude: ${maxAmplitude}`
                      );

                      if (nonZeroCount === 0) {
                        console.warn(
                          "Received all-zero audio data, no sound will be produced"
                        );
                        return; // Skip processing zero data
                      }

                      // Convert to audio buffer for playback and visualization
                      const buffer = audioContext.createBuffer(
                        1,
                        pcmData.length,
                        data.sampleRate || 16000
                      );
                      const channelData = buffer.getChannelData(0);

                      // Convert Int16 to Float32 (-1 to 1)
                      for (let i = 0; i < pcmData.length; i++) {
                        channelData[i] = pcmData[i] / 32768.0;
                      }

                      // Always play the audio
                      const source = audioContext.createBufferSource();
                      source.buffer = buffer;
                      source.connect(audioContext.destination);

                      // Add event listeners to track playback
                      source.onended = () => {
                        console.log("[Audio] Playback completed");
                      };

                      console.log(
                        `[Audio] Starting playback of ${pcmData.length} samples at ${data.sampleRate}Hz`
                      );
                      source.start();

                      // Visualize audio data
                      visualizeAudio(channelData);
                    } catch (audioError) {
                      console.error(
                        "[Audio ERROR] Failed to process or play audio:",
                        audioError.message
                      );
                      console.error("[Audio ERROR] Data details:", {
                        length: pcmData?.length,
                        sampleRate: data.sampleRate,
                        hasData: !!pcmData,
                        nonZeroSamples: nonZeroCount,
                        maxAmplitude: maxAmplitude,
                      });
                    }
                  } else {
                    console.warn("Received empty audio data");
                  }
                } else if (data.type === "status") {
                  console.log("Status update:", data);
                  connectionStatus.textContent = `Connected to server - ${
                    data.clients || 0
                  } client(s)`;
                } else if (data.type === "info") {
                  console.log("Server info:", data.message);
                  // Show message briefly in the status area
                  const originalText = connectionStatus.textContent;
                  connectionStatus.textContent = data.message;
                  setTimeout(() => {
                    connectionStatus.textContent = originalText;
                  }, 3000);
                }
              } catch (jsonError) {
                console.error(
                  "Error parsing JSON message:",
                  jsonError,
                  "Raw message:",
                  event.data.substring(0, 100)
                );
              }
            } else if (
              event.data instanceof Blob ||
              event.data instanceof ArrayBuffer
            ) {
              // Ignore binary data
              console.warn(
                "Received unexpected binary data of size:",
                event.data.byteLength || event.data.size || "unknown"
              );
            }
          } catch (e) {
            console.error("Error handling message:", e);
          }
        };
      }

      // Visualize audio data
      function visualizeAudio(audioData) {
        if (!canvasCtx) return;

        const width = canvas.width;
        const height = canvas.height;
        const bufferLength = audioData.length;

        // Clear canvas
        canvasCtx.fillStyle = "#2c3e50";
        canvasCtx.fillRect(0, 0, width, height);

        // Draw waveform
        canvasCtx.lineWidth = 2;
        canvasCtx.strokeStyle = "#3498db";
        canvasCtx.beginPath();

        const sliceWidth = width / bufferLength;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
          const v = audioData[i];
          const y = (v * 0.5 + 0.5) * height;

          if (i === 0) {
            canvasCtx.moveTo(x, y);
          } else {
            canvasCtx.lineTo(x, y);
          }

          x += sliceWidth;
        }

        canvasCtx.lineTo(width, height / 2);
        canvasCtx.stroke();
      }

      // Document loaded - start everything
      document.addEventListener("DOMContentLoaded", () => {
        // User interaction is required to start audio context in some browsers
        document.body.addEventListener("click", () => {
          if (audioContext && audioContext.state === "suspended") {
            audioContext.resume();
          }
        });

        // Initialize audio and connect to WebSocket
        if (initAudio()) {
          connectWebSocket();
        }
      });
    </script>
  </body>
</html>
